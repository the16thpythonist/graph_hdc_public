#!/usr/bin/env python
"""
Evaluate Fragment Streaming: Visualize molecules generated by BRICS fragment combination.

This standalone experiment builds a FragmentLibrary from ZINC (identical to the
streaming training experiment), samples molecules by combining random fragments,
and produces 5x5 grid visualizations of the results.

Usage:
    # Quick test
    python evaluate_fragment_streaming.py --__TESTING__ True

    # Full run (250 molecules = 10 grids)
    python evaluate_fragment_streaming.py --__DEBUG__ False

    # Custom sample count
    python evaluate_fragment_streaming.py --NUM_SAMPLES 500 --GRID_ROWS 5 --GRID_COLS 5
"""

from __future__ import annotations

import random
from collections import Counter
from io import BytesIO
from pathlib import Path
from typing import Optional

import matplotlib.pyplot as plt
import numpy as np
from matplotlib.image import imread
from pycomex.functional.experiment import Experiment
from pycomex.utils import file_namespace, folder_path
from rdkit import Chem
from rdkit.Chem import Draw

from graph_hdc.datasets.streaming_fragments import FragmentLibrary
from graph_hdc.datasets.utils import get_split

# =============================================================================
# PARAMETERS
# =============================================================================

# :param DATASET:
#     Dataset to build the fragment library from.
DATASET: str = "zinc"

# -----------------------------------------------------------------------------
# Fragment Library Configuration
# -----------------------------------------------------------------------------

# :param NUM_DATASET_SAMPLES:
#     Number of dataset molecules to use for building the fragment library.
#     None means use the entire dataset. Set to a smaller value for faster
#     iteration during development/testing.
NUM_DATASET_SAMPLES: Optional[int] = 1000

# :param MIN_FRAGMENT_ATOMS:
#     Minimum number of atoms per fragment.
MIN_FRAGMENT_ATOMS: int = 2

# :param MAX_FRAGMENT_ATOMS:
#     Maximum number of atoms per fragment.
MAX_FRAGMENT_ATOMS: int = 30

# :param REMOVE_HYDROGENS:
#     Remove explicit hydrogens from fragments at build time.
REMOVE_HYDROGENS: bool = True

# :param REMOVE_STEREO:
#     Remove all stereochemistry (chiral centers and E/Z) from fragments.
REMOVE_STEREO: bool = True

# :param REMOVE_CHARGES:
#     Remove formal charges from fragment atoms. Fragments that fail
#     sanitization after charge removal are discarded.
REMOVE_CHARGES: bool = False

# :param ENUMERATE_ATTACHMENTS:
#     If True, expand library by enumerating additional attachment positions.
ENUMERATE_ATTACHMENTS: bool = False

# :param ENUM_MAX_VARIANTS_PER_FRAGMENT:
#     Maximum enumerated attachment-point variants per fragment.
ENUM_MAX_VARIANTS_PER_FRAGMENT: int = 25

# -----------------------------------------------------------------------------
# Molecule Generation Configuration
# -----------------------------------------------------------------------------

# :param NUM_SAMPLES:
#     Total number of molecules to generate and visualize.
NUM_SAMPLES: int = 250

# :param FRAGMENTS_RANGE_MIN:
#     Minimum number of fragments per generated molecule.
FRAGMENTS_RANGE_MIN: int = 1

# :param FRAGMENTS_RANGE_MAX:
#     Maximum number of fragments per generated molecule.
FRAGMENTS_RANGE_MAX: int = 4

# :param MAX_GENERATED_NODES:
#     Maximum number of atoms in generated molecules.
MAX_GENERATED_NODES: int = 40

# :param MAX_RETRIES_PER_SAMPLE:
#     Maximum number of generation attempts per successful molecule.
MAX_RETRIES_PER_SAMPLE: int = 50

# :param SEED:
#     Random seed for reproducibility.
SEED: int = 42

# -----------------------------------------------------------------------------
# Visualization Configuration
# -----------------------------------------------------------------------------

# :param GRID_ROWS:
#     Number of rows in each visualization grid.
GRID_ROWS: int = 5

# :param GRID_COLS:
#     Number of columns in each visualization grid.
GRID_COLS: int = 5

# :param MOL_IMAGE_SIZE:
#     Size (width, height) for each individual molecule image rendered by RDKit.
MOL_IMAGE_SIZE: tuple = (300, 300)

# :param FIGURE_DPI:
#     DPI for saved figure files.
FIGURE_DPI: int = 150

# -----------------------------------------------------------------------------
# Debug/Testing Modes
# -----------------------------------------------------------------------------

# :param __DEBUG__:
#     Debug mode - reuses same output folder during development.
__DEBUG__: bool = True

# :param __TESTING__:
#     Testing mode - runs with minimal iterations for validation.
__TESTING__: bool = False


# =============================================================================
# EXPERIMENT
# =============================================================================

experiment = Experiment(
    base_path=folder_path(__file__),
    namespace=file_namespace(__file__),
    glob=globals(),
)


def _strip_dummy_atoms(mol: Chem.Mol) -> Optional[Chem.Mol]:
    """Remove leftover BRICS dummy atoms (* / atomic number 0) from a molecule."""
    rw = Chem.RWMol(mol)
    dummy_idxs = [a.GetIdx() for a in rw.GetAtoms() if a.GetAtomicNum() == 0]
    for idx in sorted(dummy_idxs, reverse=True):
        rw.RemoveAtom(idx)
    try:
        Chem.SanitizeMol(rw)
        return rw.GetMol()
    except Exception:
        return None


def _generate_molecules(
    library: FragmentLibrary,
    num_samples: int,
    fragments_range: tuple,
    max_nodes: int,
    max_retries: int,
) -> list[dict]:
    """
    Generate molecules by combining random fragments.

    Returns list of dicts with keys: mol, smiles, num_fragments.
    """
    results = []
    total_attempts = 0
    rejection_reasons: Counter = Counter()

    while len(results) < num_samples:
        if total_attempts >= num_samples * max_retries:
            break

        total_attempts += 1
        n_frags = random.randint(fragments_range[0], fragments_range[1])
        fragments = library.sample_fragments(n_frags)

        if n_frags == 1:
            mol = fragments[0]
        else:
            mol = library.combine_fragments(fragments)

        if mol is None:
            rejection_reasons["combination_failed"] += 1
            continue

        # Strip leftover dummy atoms from unused attachment points
        mol = _strip_dummy_atoms(mol)
        if mol is None:
            rejection_reasons["sanitize_fail"] += 1
            continue

        # Validate
        smiles = Chem.MolToSmiles(mol)
        if "." in smiles:
            rejection_reasons["disconnected"] += 1
            continue

        if mol.GetNumAtoms() > max_nodes:
            rejection_reasons["oversized"] += 1
            continue

        results.append({
            "mol": mol,
            "smiles": smiles,
            "num_fragments": n_frags,
        })

    return results, total_attempts, rejection_reasons


def _mol_to_image(mol: Chem.Mol, size: tuple) -> np.ndarray:
    """Render an RDKit molecule to a numpy RGB array."""
    img = Draw.MolToImage(mol, size=size)
    return np.array(img)


def _save_grid(
    molecules: list[dict],
    grid_index: int,
    rows: int,
    cols: int,
    mol_size: tuple,
    output_dir: Path,
    dpi: int,
) -> Path:
    """Create and save a rows x cols grid of molecule images."""
    fig, axes = plt.subplots(rows, cols, figsize=(cols * 3.5, rows * 4.0))

    for i in range(rows):
        for j in range(cols):
            ax = axes[i, j]
            idx = i * cols + j

            if idx < len(molecules):
                entry = molecules[idx]
                img = _mol_to_image(entry["mol"], mol_size)
                ax.imshow(img)

                # Title: num_fragments + SMILES (truncated if long)
                smiles = entry["smiles"]
                if len(smiles) > 35:
                    smiles = smiles[:32] + "..."
                ax.set_title(
                    f"frags={entry['num_fragments']}\n{smiles}",
                    fontsize=7,
                    pad=3,
                )
            else:
                ax.set_visible(False)

            ax.set_xticks([])
            ax.set_yticks([])

    fig.tight_layout()
    plot_path = output_dir / f"molecules_grid_{grid_index:03d}.png"
    fig.savefig(plot_path, dpi=dpi, bbox_inches="tight")
    plt.close(fig)
    return plot_path


@experiment
def run(e: Experiment):
    random.seed(e.SEED)
    np.random.seed(e.SEED)

    # -----------------------------------------------------------------
    # Build fragment library (same as streaming experiment)
    # -----------------------------------------------------------------
    e.log("Building fragment library from ZINC...")

    zinc_train = get_split("train", dataset=e.DATASET)
    e.log(f"ZINC train size: {len(zinc_train)}")

    if e.NUM_DATASET_SAMPLES is not None:
        zinc_train = list(zinc_train)[:e.NUM_DATASET_SAMPLES]
        e.log(f"Subsampled to {len(zinc_train)} molecules for library building")

    fragment_library = FragmentLibrary(
        min_atoms=e.MIN_FRAGMENT_ATOMS,
        max_atoms=e.MAX_FRAGMENT_ATOMS,
        remove_hydrogens=e.REMOVE_HYDROGENS,
        remove_stereo=e.REMOVE_STEREO,
        remove_charges=e.REMOVE_CHARGES,
    )
    fragment_library.build_from_dataset(zinc_train, show_progress=True)
    e.log(f"Fragment library: {fragment_library.num_fragments} fragments")

    if e.ENUMERATE_ATTACHMENTS:
        n_before = fragment_library.num_fragments
        n_added = fragment_library.expand_with_enumerated_positions(
            max_new_points=e.ENUM_MAX_VARIANTS_PER_FRAGMENT,
        )
        e.log(
            f"Enumerated attachment expansion: {n_before} -> "
            f"{fragment_library.num_fragments} fragments (+{n_added} variants)"
        )
        e["data/num_enumerated_variants"] = n_added

    e["data/num_fragments"] = fragment_library.num_fragments

    # Save fragment library
    library_path = Path(e.path) / "fragment_library.pkl"
    fragment_library.save(library_path)
    e.log(f"Saved fragment library to: {library_path}")

    # -----------------------------------------------------------------
    # Generate molecules
    # -----------------------------------------------------------------
    e.log(f"\nGenerating {e.NUM_SAMPLES} molecules...")

    molecules, total_attempts, rejection_reasons = _generate_molecules(
        library=fragment_library,
        num_samples=e.NUM_SAMPLES,
        fragments_range=(e.FRAGMENTS_RANGE_MIN, e.FRAGMENTS_RANGE_MAX),
        max_nodes=e.MAX_GENERATED_NODES,
        max_retries=e.MAX_RETRIES_PER_SAMPLE,
    )

    e.log(f"Generated {len(molecules)} molecules in {total_attempts} attempts")
    validity_rate = len(molecules) / total_attempts if total_attempts > 0 else 0.0
    e.log(f"Validity rate: {validity_rate:.2%}")

    if rejection_reasons:
        e.log("Rejection reasons:")
        for reason, count in rejection_reasons.most_common():
            e.log(f"  {reason}: {count}")

    e["results/num_generated"] = len(molecules)
    e["results/total_attempts"] = total_attempts
    e["results/validity_rate"] = validity_rate
    e["results/rejection_reasons"] = dict(rejection_reasons)

    if len(molecules) == 0:
        e.log("ERROR: No molecules generated, cannot create visualizations.")
        return

    # -----------------------------------------------------------------
    # Summary statistics
    # -----------------------------------------------------------------
    e.log("\n--- Summary Statistics ---")

    # Fragment count distribution
    frag_counts = Counter(m["num_fragments"] for m in molecules)
    e.log("Fragments per molecule:")
    for n_frags in sorted(frag_counts.keys()):
        e.log(f"  {n_frags} fragments: {frag_counts[n_frags]} molecules")
    e["results/fragment_count_distribution"] = dict(frag_counts)

    # Atom count distribution
    atom_counts = [m["mol"].GetNumAtoms() for m in molecules]
    e.log(f"Atom counts: min={min(atom_counts)}, max={max(atom_counts)}, "
          f"mean={np.mean(atom_counts):.1f}, median={np.median(atom_counts):.1f}")
    e["results/atom_count_stats"] = {
        "min": int(min(atom_counts)),
        "max": int(max(atom_counts)),
        "mean": float(np.mean(atom_counts)),
        "median": float(np.median(atom_counts)),
    }

    # Atom type distribution
    element_counts: Counter = Counter()
    for m in molecules:
        for atom in m["mol"].GetAtoms():
            element_counts[atom.GetSymbol()] += 1
    e.log("Atom type distribution:")
    for elem, count in element_counts.most_common():
        e.log(f"  {elem}: {count}")
    e["results/atom_type_distribution"] = dict(element_counts)

    # Unique SMILES
    unique_smiles = set(m["smiles"] for m in molecules)
    e.log(f"Unique molecules: {len(unique_smiles)}/{len(molecules)} "
          f"({len(unique_smiles)/len(molecules):.1%})")
    e["results/num_unique"] = len(unique_smiles)
    e["results/uniqueness_rate"] = len(unique_smiles) / len(molecules)

    # -----------------------------------------------------------------
    # Statistics plots
    # -----------------------------------------------------------------
    output_dir = Path(e.path)

    # Fragment count histogram
    fig, ax = plt.subplots(figsize=(6, 4))
    frag_keys = sorted(frag_counts.keys())
    ax.bar(frag_keys, [frag_counts[k] for k in frag_keys], edgecolor="black", linewidth=0.5)
    ax.set_xlabel("Number of Fragments")
    ax.set_ylabel("Count")
    ax.set_title("Fragments per Molecule")
    ax.set_xticks(frag_keys)
    fig.tight_layout()
    fig.savefig(output_dir / "fragment_count_histogram.png", dpi=e.FIGURE_DPI)
    plt.close(fig)

    # Atom count histogram
    fig, ax = plt.subplots(figsize=(6, 4))
    ax.hist(atom_counts, bins=30, edgecolor="black", linewidth=0.5)
    ax.set_xlabel("Number of Atoms")
    ax.set_ylabel("Count")
    ax.set_title("Atom Count Distribution")
    fig.tight_layout()
    fig.savefig(output_dir / "atom_count_histogram.png", dpi=e.FIGURE_DPI)
    plt.close(fig)

    e.log(f"\nSaved statistics plots to: {output_dir}")

    # -----------------------------------------------------------------
    # Molecule grid visualizations
    # -----------------------------------------------------------------
    grid_size = e.GRID_ROWS * e.GRID_COLS
    num_grids = (len(molecules) + grid_size - 1) // grid_size

    e.log(f"\nCreating {num_grids} visualization grid(s) ({e.GRID_ROWS}x{e.GRID_COLS})...")

    for grid_idx in range(num_grids):
        start = grid_idx * grid_size
        end = min(start + grid_size, len(molecules))
        grid_mols = molecules[start:end]

        plot_path = _save_grid(
            molecules=grid_mols,
            grid_index=grid_idx,
            rows=e.GRID_ROWS,
            cols=e.GRID_COLS,
            mol_size=e.MOL_IMAGE_SIZE,
            output_dir=output_dir,
            dpi=e.FIGURE_DPI,
        )
        e.log(f"  Saved grid {grid_idx}: {plot_path.name} ({len(grid_mols)} molecules)")

    e.log(f"\nDone! {len(molecules)} molecules visualized in {num_grids} grids.")


# =============================================================================
# Testing Mode
# =============================================================================


@experiment.testing
def testing(e: Experiment):
    """Quick test mode with minimal parameters."""
    e.NUM_DATASET_SAMPLES = 500
    e.NUM_SAMPLES = 10
    e.GRID_ROWS = 2
    e.GRID_COLS = 3
    e.MAX_RETRIES_PER_SAMPLE = 20


# =============================================================================
# Entry Point
# =============================================================================

experiment.run_if_main()
